<!doctype html>
<html lang="fr">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Rapport</title>
  <style>
    body {
      margin: auto;
      max-width: 600px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      font-size: 13pt;
    }

    code {
      padding: 0 4px;
      color: white;
      background-color: #424242;
      border-radius: 4px;
      font-size: 0.9em;
    }

    .control {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 4px;
    }

    .card {
      margin: 8pt 0;
      padding: 8pt;
      background-color: #f0f0f0;
      border-radius: 4px;
    }

    .hidden {
      display: none;
    }

    .diagnosis::before, .suggestion::before {
      margin: 0 6pt;
      float : left;
      font-size: 2.2rem;
    }

    .diagnosis::before {
      content: "ü©∫";
    }

    .suggestion::before {
      content: "üí°";
    }
  </style>
  <script type="module">
    const previousEl = document.querySelector('#previous')
    const indexEl = document.querySelector('#index')
    const nextEl = document.querySelector('#next')
    const cardEls = Array.from(document.querySelectorAll('.card:not(:first-child)'))

    let index = 0
    update()

    document.querySelector('#next').addEventListener('click', () => {
      index++
      update()
    })

    document.querySelector('#previous').addEventListener('click', () => {
      index--
      update()
    })

    function update() {
      indexEl.textContent = `${index + 1}/${cardEls.length}`

      if (index <= 0) {
        previousEl.setAttribute('disabled', true)
      } else {
        previousEl.removeAttribute('disabled')
      }

      if (index >= cardEls.length - 1) {
        nextEl.setAttribute('disabled', true)
      } else {
        nextEl.removeAttribute('disabled')
      }

      for (let i = 0; i < cardEls.length; i++) {
        const card = cardEls[i]
        if (i === index) {
          card.classList.remove('hidden')
        } else {
          card.classList.add('hidden')
        }
      }
    }
  </script>
</head>

<body>
  <div class="control card">
    <button id="previous">ü†î</button>
    <span id="index"></span>
    <button id="next">ü†ñ</button>
  </div>
  <div class="card">
  <h2><code>Tile.equals(java.lang.Object)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.equals(java.lang.Object)</code>
    a √©t√©
    remplac√© par
    <code>return true;</code>.
    Pourtant,
    le test <code>Test2048.testTileEquals</code> n'a pas √©chou√©.
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 38
    dans une expression de type <code>boolean</code>.
    En effet, la valeur
    √©tait <code>false</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>true</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 23
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 52
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 85
    dans une expression de type <code>int</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 54
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 48
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 85
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 53
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 69
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 38
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 82
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 53
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 23
    dans une expression de type <code>int</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 87
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 69
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 24
    dans une expression de type <code>int</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 23
    dans une expression de type <code>int</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 39
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 65
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 24
    dans une expression de type <code>int</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 19
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 70
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 69
    dans une expression de type <code>boolean</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 53
    dans une expression de type <code>int</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 20
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 24
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 80
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 64
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 85
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 66
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 39
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 35
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 24
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 70
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 23
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 33
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 86
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 49
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 1;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 81
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>1</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 23
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 52
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 85
    dans une expression de type <code>int</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 54
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 48
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 85
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 53
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 69
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 38
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 82
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 53
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 23
    dans une expression de type <code>int</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 87
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 69
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 24
    dans une expression de type <code>int</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 23
    dans une expression de type <code>int</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 39
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 65
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 24
    dans une expression de type <code>int</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 19
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 70
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 69
    dans une expression de type <code>boolean</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 53
    dans une expression de type <code>int</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 20
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 24
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 80
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 64
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 85
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 66
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 39
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 35
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 24
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 70
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 23
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 33
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 86
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 49
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.getNearestPower2(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.getNearestPower2(int)</code>
    a √©t√©
    remplac√© par
    <code>return 0;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileEquals</code></li>
      <li><code>Test2048.testTileGetValue</code></li>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 81
    dans une expression de type <code>be.unamur.game2048.models.Tile</code>.
    En effet, la valeur
    de la variable d'instance <code>value</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>value</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></li>
      <li><code>Tile.toString()</code></li>
      <li><code>Tile.getValue()</code></li>
      <li><code>Tile.mergeWith(be.unamur.game2048.models.Tile)</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Tile.canMergeWith(be.unamur.game2048.models.Tile)</code>
    a √©t√©
    remplac√© par
    <code>return true;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testTileIsMerged</code></li>
      <li><code>Test2048.testTileMergeWith</code></li>
      <li><code>Test2048.testTileCanMergeWith</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 69
    dans une expression de type <code>boolean</code>.
    En effet, la valeur
    √©tait <code>false</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>true</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
  </p>
  </div>
  <div class="card">
  <h2><code>GameController.updateScore(int)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>GameController.updateScore(int)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>GameController.startGame(be.unamur.game2048.models.Tile[][])</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>GameController.startGame(be.unamur.game2048.models.Tile[][])</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>GameController.moveRight(boolean)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>GameController.moveRight(boolean)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>GameController.moveLeft(boolean)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>GameController.moveLeft(boolean)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>GameController.startGame()</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>GameController.startGame()</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>GameController.fillFirstEmptyTile()</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>GameController.fillFirstEmptyTile()</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>GameController.moveDown(boolean)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>GameController.moveDown(boolean)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>GameController.moveUp(boolean)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>GameController.moveUp(boolean)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>Grid.setTile(int, be.unamur.game2048.models.Tile)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>Grid.setTile(int, be.unamur.game2048.models.Tile)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>Grid.clearMerged()</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>Grid.clearMerged()</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>Grid.getRow(int)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>Grid.getRow(int)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>Grid.getCol(int)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>Grid.getCol(int)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>Grid.getTile(int, int)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>Grid.getTile(int, int)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>Grid.getTile(int)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>Grid.getTile(int)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>Grid.getLength()</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>Grid.getLength()</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
</body>

</html>