<!doctype html>
<html lang="fr">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Rapport</title>
  <style>
    body {
      margin: auto;
      max-width: 600px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      font-size: 13pt;
    }

    code {
      padding: 0 4px;
      color: white;
      background-color: #424242;
      border-radius: 4px;
      font-size: 0.9em;
    }

    .control {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 4px;
    }

    .card {
      margin: 8pt 0;
      padding: 8pt;
      background-color: #f0f0f0;
      border-radius: 4px;
    }

    .hidden {
      display: none;
    }

    .diagnosis::before, .suggestion::before {
      margin: 0 6pt;
      float : left;
      font-size: 2.2rem;
    }

    .diagnosis::before {
      content: "ü©∫";
    }

    .suggestion::before {
      content: "üí°";
    }
  </style>
  <script type="module">
    const previousEl = document.querySelector('#previous')
    const indexEl = document.querySelector('#index')
    const nextEl = document.querySelector('#next')
    const cardEls = Array.from(document.querySelectorAll('.card:not(:first-child)'))

    let index = 0
    update()

    document.querySelector('#next').addEventListener('click', () => {
      index++
      update()
    })

    document.querySelector('#previous').addEventListener('click', () => {
      index--
      update()
    })

    function update() {
      indexEl.textContent = `${index + 1}/${cardEls.length}`

      if (index <= 0) {
        previousEl.setAttribute('disabled', true)
      } else {
        previousEl.removeAttribute('disabled')
      }

      if (index >= cardEls.length - 1) {
        nextEl.setAttribute('disabled', true)
      } else {
        nextEl.removeAttribute('disabled')
      }

      for (let i = 0; i < cardEls.length; i++) {
        const card = cardEls[i]
        if (i === index) {
          card.classList.remove('hidden')
        } else {
          card.classList.add('hidden')
        }
      }
    }
  </script>
</head>

<body>
  <div class="control card">
    <button id="previous">ü†î</button>
    <span id="index"></span>
    <button id="next">ü†ñ</button>
  </div>
  <div class="card">
  <h2><code>Grid.setTile(int, be.unamur.game2048.models.Tile)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Grid.setTile(int, be.unamur.game2048.models.Tile)</code>
    a √©t√©
    supprim√©.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testInitialHighScore</code></li>
      <li><code>Test2048.testInitialScore</code></li>
      <li><code>Test2048.testGameStateRunning</code></li>
    </ul>
  </p>
  <p class="infection diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence est observable dans une m√©thode mais pas dans les tests
    actuels.
    En effet, dans un appel de <code>setTile</code>,
    l'argument n&deg;0
    √©tait <code>1</code> avec la m√©thode originale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre
    d'ajouter un test qui cible directement le r√©sultat de
    <code>setTile</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Grid.getTile(int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Grid.getTile(int)</code>
    a √©t√©
    remplac√© par
    <code>return null;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testInitialHighScore</code></li>
      <li><code>Test2048.testInitialScore</code></li>
      <li><code>Test2048.testGameStateRunning</code></li>
    </ul>
  </p>
  <p class="infection diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence est observable dans une m√©thode mais pas dans les tests
    actuels.
    En effet, dans un appel de <code>getTile</code>,
    la valeur de retour
    √©tait non-null avec la m√©thode originale, alors qu'elle
    vaut null avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre
    d'ajouter un test qui cible directement le r√©sultat de
    <code>getTile</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>Grid.getTile(int, int)</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>Grid.getTile(int, int)</code>
    a √©t√©
    remplac√© par
    <code>return null;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testGameStateRunning</code></li>
      <li><code>Test2048.testInitialHighScore</code></li>
      <li><code>Test2048.testInitialScore</code></li>
    </ul>
  </p>
  <p class="infection diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence est observable dans une m√©thode mais pas dans les tests
    actuels.
    En effet, dans un appel de <code>getTile</code>,
    la valeur de retour
    √©tait non-null avec la m√©thode originale, alors qu'elle
    vaut null avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre
    d'ajouter un test qui cible directement le r√©sultat de
    <code>getTile</code>.
  </p>
  </div>
  <div class="card">
  <h2><code>GameController.fillFirstEmptyTile()</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>GameController.fillFirstEmptyTile()</code>
    a √©t√©
    remplac√© par
    <code>return true;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testInitialHighScore</code></li>
      <li><code>Test2048.testInitialScore</code></li>
      <li><code>Test2048.testGameStateRunning</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 164
    dans une expression de type <code>be.unamur.game2048.controllers.GameController</code>.
    En effet, la valeur
    de la variable d'instance <code>tileAdded</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>tileAdded</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>GameController.fillFirstEmptyTile()</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>GameController.fillFirstEmptyTile()</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>GameController.fillFirstEmptyTile()</code>
    a √©t√©
    remplac√© par
    <code>return true;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testInitialHighScore</code></li>
      <li><code>Test2048.testInitialScore</code></li>
      <li><code>Test2048.testGameStateRunning</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 173
    dans une expression de type <code>be.unamur.game2048.controllers.GameController</code>.
    En effet, la valeur
    de la variable d'instance <code>tileAdded</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>tileAdded</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>GameController.fillFirstEmptyTile()</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>GameController.fillFirstEmptyTile()</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>GameController.fillFirstEmptyTile()</code>
    a √©t√©
    remplac√© par
    <code>return true;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testInitialHighScore</code></li>
      <li><code>Test2048.testInitialScore</code></li>
      <li><code>Test2048.testGameStateRunning</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 182
    dans une expression de type <code>be.unamur.game2048.controllers.GameController</code>.
    En effet, la valeur
    de la variable d'instance <code>tileAdded</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>tileAdded</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>GameController.fillFirstEmptyTile()</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>GameController.fillFirstEmptyTile()</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>GameController.fillFirstEmptyTile()</code>
    a √©t√©
    remplac√© par
    <code>return false;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testInitialHighScore</code></li>
      <li><code>Test2048.testInitialScore</code></li>
      <li><code>Test2048.testGameStateRunning</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 164
    dans une expression de type <code>be.unamur.game2048.controllers.GameController</code>.
    En effet, la valeur
    de la variable d'instance <code>tileAdded</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>tileAdded</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>GameController.fillFirstEmptyTile()</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>GameController.fillFirstEmptyTile()</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>GameController.fillFirstEmptyTile()</code>
    a √©t√©
    remplac√© par
    <code>return false;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testInitialHighScore</code></li>
      <li><code>Test2048.testInitialScore</code></li>
      <li><code>Test2048.testGameStateRunning</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 173
    dans une expression de type <code>be.unamur.game2048.controllers.GameController</code>.
    En effet, la valeur
    de la variable d'instance <code>tileAdded</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>tileAdded</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>GameController.fillFirstEmptyTile()</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>GameController.fillFirstEmptyTile()</code></h2>
  <p class="hint issue">
    Le corps de la m√©thode
    <code>GameController.fillFirstEmptyTile()</code>
    a √©t√©
    remplac√© par
    <code>return false;</code>.
    Pourtant,
    aucun des tests suivants n'a √©chou√©&nbsp;:
    <ul>
      <li><code>Test2048.testInitialHighScore</code></li>
      <li><code>Test2048.testInitialScore</code></li>
      <li><code>Test2048.testGameStateRunning</code></li>
    </ul>
  </p>
  <p class="observation diagnosis">
    Il est possible d'observer une diff√©rence dans l'√©tat du programme selon
    que l'on utilise la m√©thode originale ou la m√©thode modifi√©e.
    Cette diff√©rence se situe dans <code>Test2048.java</code>
    √† la ligne 182
    dans une expression de type <code>be.unamur.game2048.controllers.GameController</code>.
    En effet, la valeur
    de la variable d'instance <code>tileAdded</code>
    √©tait <code>2</code> avec la m√©thode orignale, alors qu'elle
    vaut <code>0</code> avec la m√©thode modifi√©e.
  </p>
  <p class="suggestion">
    Ainsi, une solution pourrait √™tre d'ajouter une assertion ciblant
    <code>tileAdded</code>.
    Voici la liste des m√©thodes que vous pourriez appeler pour ce faire&nbsp;:
    <ul>
      <li><code>GameController.fillFirstEmptyTile()</code></li>
    </ul>
  </p>
  </div>
  <div class="card">
  <h2><code>GameController.updateScore(int)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>GameController.updateScore(int)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>GameController.startGame(be.unamur.game2048.models.Tile[][])</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>GameController.startGame(be.unamur.game2048.models.Tile[][])</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>GameController.moveRight(boolean)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>GameController.moveRight(boolean)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>GameController.moveLeft(boolean)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>GameController.moveLeft(boolean)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>GameController.moveDown(boolean)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>GameController.moveDown(boolean)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>GameController.moveUp(boolean)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>GameController.moveUp(boolean)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>Grid.clearMerged()</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>Grid.clearMerged()</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>Grid.getRow(int)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>Grid.getRow(int)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>Grid.getCol(int)</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>Grid.getCol(int)</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
  <div class="card">
  <h2><code>Grid.getLength()</code></h2>
  <p class="uncovered issue">
    La m√©thode <code>Grid.getLength()</code> n'est ex√©cut√©e par
    aucun test.
  </p>
  <p class="suggestion">
    Vous pourriez √©crire un nouveau test qui cible cette m√©thode.
  </p>  </div>
</body>

</html>